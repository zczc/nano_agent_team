"""
Tool Base Class Module

Defines the abstract base class BaseTool for all tools in the system.
All concrete tool classes (e.g., SearchTool, WebReaderTool) must inherit from this class and implement its abstract methods.

Design Philosophy:
    - Interface Consistency: Enforce name, description, and parameter definition via abstract methods.
    - Compatibility: Provide `to_openai_schema` method to convert tool definition to OpenAI Function Calling format.
    - Configurability: Provide `configure` hook for injecting runtime context after instantiation.
    - Status Feedback: Provide unified UI feedback mechanism via `get_status_message`.
"""

from abc import ABC, abstractmethod
from typing import Dict, Any
from functools import wraps
from backend.infra.config import Config
from backend.utils.langfuse_manager import observe
from backend.llm.decorators import resolve_path_variables

class BaseTool(ABC):
    """
    Abstract Base Class for all executable tools
    """
    
    def __init_subclass__(cls, **kwargs):
        """
        Automatically add Langfuse tracing and path variable resolution to execute method of all subclasses
        """
        super().__init_subclass__(**kwargs)
        if hasattr(cls, 'execute') and callable(cls.execute):
            if 'execute' in cls.__dict__:
                # 1. Resolve paths
                cls.execute = resolve_path_variables(cls.execute)
                # 2. Add observability
                cls.execute = observe(as_type="span")(cls.execute)

    @property
    @abstractmethod
    def name(self) -> str:
        """Tool unique identifier name (for LLM recognition)"""
        pass
    
    @property
    @abstractmethod
    def description(self) -> str:
        """Tool functional description (for LLM understanding)"""
        pass
    
    @property
    @abstractmethod
    def parameters_schema(self) -> Dict[str, Any]:
        """
        Tool parameter JSON Schema definition
        Follows JSON Schema spec, describing accepted parameters, types, and descriptions.
        """
        pass
    
    def configure(self, context: Dict[str, Any]):
        """
        Tool configuration hook
        Allows injecting dynamic configuration (e.g., API Key, paths) after instantiation but before execution.
        """
        pass
    
    @abstractmethod
    def execute(self, **kwargs) -> Any:
        """
        Execute core tool logic
        
        Args:
            **kwargs: Parameters generated by LLM based on parameters_schema
            
        Returns:
            Any: Execution result, usually string or JSON serializable object
        """
        pass
    
    def get_status_message(self, **kwargs) -> str:
        """
        Get tool execution status message
        Used for real-time Agent action feedback in UI layer.
        """
        return f"\n\nðŸ”§ Calling tool: {self.name}...\n"
    
    def to_openai_schema(self) -> Dict[str, Any]:
        """
        Convert tool to OpenAI Function Calling format Schema
        Used for passing to LLM in API calls.
        """
        return {
            "type": "function",
            "function": {
                "name": self.name,
                "description": self.description,
                "parameters": self.parameters_schema
            }
        }


